From 53b504f1bcfbfc2e796f1afa34686fd276b136b3 Mon Sep 17 00:00:00 2001
From: Agriya Khetarpal <74401230+agriyakhetarpal@users.noreply.github.com>
Date: Thu, 28 Nov 2024 18:17:41 +0530
Subject: [PATCH 4/4] Adapt to NumPy v2

This is a custom patch that applies modifications
required for NumPy 2.0 support that were
introduced in later versions of Matplotlib for
our version.

1. np.row_stack changed to use np.vstack
2. Remove instances of np.recarray
3. np.Inf and np.NaN changed to np.inf and np.nan
4. Changes for np.newbyteorder views
5. np.VisibleDeprecationWarning moved to np.exceptions.VisibileDeprecationWarning
6. np.in1d is now np.isin
7. setup.py now forces NumPy 2 at build-time
 and runtime as an additional measure

Co-Authored-By: Kyle Sunden <git@ksunden.space>
Co-Authored-By: Elliott Sales de Andrade <quantum.analyst@gmail.com>
Co-Authored-By: Tim Hoffmann <2836374+timhoffm@users.noreply.github.com>
---
 examples/lines_bars_and_markers/fill_between_alpha.py  |  9 ++++-----
 examples/lines_bars_and_markers/scatter_demo2.py       |  9 ++++-----
 examples/lines_bars_and_markers/scatter_piecharts.py   |  6 +++---
 .../date_index_formatter.py                            |  9 ++++-----
 examples/ticks/centered_ticklabels.py                  |  7 +++----
 lib/matplotlib/axes/_axes.py                           |  6 +++---
 lib/matplotlib/axes/_base.py                           |  2 +-
 lib/matplotlib/cbook/__init__.py                       |  7 ++++---
 lib/matplotlib/colors.py                               |  5 +++--
 lib/matplotlib/contour.py                              |  6 +++---
 lib/matplotlib/projections/polar.py                    |  2 +-
 lib/matplotlib/stackplot.py                            |  2 +-
 lib/matplotlib/tests/test_axes.py                      |  8 ++++----
 lib/matplotlib/tests/test_colors.py                    | 10 +++++-----
 lib/matplotlib/tests/test_image.py                     |  2 +-
 lib/matplotlib/tests/test_triangulation.py             |  2 +-
 lib/mpl_toolkits/mplot3d/art3d.py                      |  4 ++--
 setup.py                                               |  4 ++--
 18 files changed, 49 insertions(+), 51 deletions(-)

diff --git a/examples/lines_bars_and_markers/fill_between_alpha.py b/examples/lines_bars_and_markers/fill_between_alpha.py
index 30e7f6be3d..54a8c32f0b 100644
--- a/examples/lines_bars_and_markers/fill_between_alpha.py
+++ b/examples/lines_bars_and_markers/fill_between_alpha.py
@@ -18,15 +18,14 @@ import matplotlib.cbook as cbook
 
 
 # load up some sample financial data
-r = (cbook.get_sample_data('goog.npz', np_load=True)['price_data']
-     .view(np.recarray))
+r = cbook.get_sample_data('goog.npz', np_load=True)['price_data']
 # create two subplots with the shared x and y axes
 fig, (ax1, ax2) = plt.subplots(1, 2, sharex=True, sharey=True)
 
-pricemin = r.close.min()
+pricemin = r["close"].min()
 
-ax1.plot(r.date, r.close, lw=2)
-ax2.fill_between(r.date, pricemin, r.close, alpha=0.7)
+ax1.plot(r["date"], r["close"], lw=2)
+ax2.fill_between(r["date"], pricemin, r["close"], alpha=0.7)
 
 for ax in ax1, ax2:
     ax.grid(True)
diff --git a/examples/lines_bars_and_markers/scatter_demo2.py b/examples/lines_bars_and_markers/scatter_demo2.py
index 7a669ff05d..1c8d8cb34b 100644
--- a/examples/lines_bars_and_markers/scatter_demo2.py
+++ b/examples/lines_bars_and_markers/scatter_demo2.py
@@ -12,15 +12,14 @@ import matplotlib.cbook as cbook
 # Load a numpy record array from yahoo csv data with fields date, open, close,
 # volume, adj_close from the mpl-data/example directory. The record array
 # stores the date as an np.datetime64 with a day unit ('D') in the date column.
-price_data = (cbook.get_sample_data('goog.npz', np_load=True)['price_data']
-              .view(np.recarray))
+price_data = cbook.get_sample_data('goog.npz', np_load=True)['price_data']
 price_data = price_data[-250:]  # get the most recent 250 trading days
 
-delta1 = np.diff(price_data.adj_close) / price_data.adj_close[:-1]
+delta1 = np.diff(price_data["adj_close"]) / price_data["adj_close"][:-1]
 
 # Marker size in units of points^2
-volume = (15 * price_data.volume[:-2] / price_data.volume[0])**2
-close = 0.003 * price_data.close[:-2] / 0.003 * price_data.open[:-2]
+volume = (15 * price_data["volume"][:-2] / price_data["volume"][0])**2
+close = 0.003 * price_data["close"][:-2] / 0.003 * price_data["open"][:-2]
 
 fig, ax = plt.subplots()
 ax.scatter(delta1[:-1], delta1[1:], c=close, s=volume, alpha=0.5)
diff --git a/examples/lines_bars_and_markers/scatter_piecharts.py b/examples/lines_bars_and_markers/scatter_piecharts.py
index 09eb1c0b6b..8eec37272e 100644
--- a/examples/lines_bars_and_markers/scatter_piecharts.py
+++ b/examples/lines_bars_and_markers/scatter_piecharts.py
@@ -22,17 +22,17 @@ sizes = np.array([60, 80, 120])
 # these are just the origin (0, 0) + some (cos, sin) points on a circle
 x1 = np.cos(2 * np.pi * np.linspace(0, r1))
 y1 = np.sin(2 * np.pi * np.linspace(0, r1))
-xy1 = np.row_stack([[0, 0], np.column_stack([x1, y1])])
+xy1 = np.vstack([[0, 0], np.column_stack([x1, y1])])
 s1 = np.abs(xy1).max()
 
 x2 = np.cos(2 * np.pi * np.linspace(r1, r2))
 y2 = np.sin(2 * np.pi * np.linspace(r1, r2))
-xy2 = np.row_stack([[0, 0], np.column_stack([x2, y2])])
+xy2 = np.vstack([[0, 0], np.column_stack([x2, y2])])
 s2 = np.abs(xy2).max()
 
 x3 = np.cos(2 * np.pi * np.linspace(r2, 1))
 y3 = np.sin(2 * np.pi * np.linspace(r2, 1))
-xy3 = np.row_stack([[0, 0], np.column_stack([x3, y3])])
+xy3 = np.vstack([[0, 0], np.column_stack([x3, y3])])
 s3 = np.abs(xy3).max()
 
 fig, ax = plt.subplots()
diff --git a/examples/text_labels_and_annotations/date_index_formatter.py b/examples/text_labels_and_annotations/date_index_formatter.py
index 4da74ebb76..f800a25b04 100644
--- a/examples/text_labels_and_annotations/date_index_formatter.py
+++ b/examples/text_labels_and_annotations/date_index_formatter.py
@@ -14,13 +14,12 @@ import matplotlib.cbook as cbook
 # Load a numpy record array from yahoo csv data with fields date, open, close,
 # volume, adj_close from the mpl-data/example directory. The record array
 # stores the date as an np.datetime64 with a day unit ('D') in the date column.
-r = (cbook.get_sample_data('goog.npz', np_load=True)['price_data']
-     .view(np.recarray))
+r = cbook.get_sample_data('goog.npz', np_load=True)['price_data']
 r = r[-30:]  # get the last 30 days
 
 # first we'll do it the default way, with gaps on weekends
 fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 4))
-ax1.plot(r.date, r.adj_close, 'o-')
+ax1.plot(r["date"], r["adj_close"], 'o-')
 ax1.set_title("Default")
 fig.autofmt_xdate()
 
@@ -31,10 +30,10 @@ ind = np.arange(N)  # the evenly spaced plot indices
 
 def format_date(x, pos=None):
     thisind = np.clip(int(x + 0.5), 0, N - 1)
-    return r.date[thisind].item().strftime('%Y-%m-%d')
+    return r["date"][thisind].item().strftime('%Y-%m-%d')
 
 
-ax2.plot(ind, r.adj_close, 'o-')
+ax2.plot(ind, r["adj_close"], 'o-')
 # Use automatic FuncFormatter creation
 ax2.xaxis.set_major_formatter(format_date)
 ax2.set_title("Custom tick formatter")
diff --git a/examples/ticks/centered_ticklabels.py b/examples/ticks/centered_ticklabels.py
index 61431e3ab2..da83c6be04 100644
--- a/examples/ticks/centered_ticklabels.py
+++ b/examples/ticks/centered_ticklabels.py
@@ -24,12 +24,11 @@ import matplotlib.ticker as ticker
 import matplotlib.pyplot as plt
 
 # load some financial data; Google's stock price
-r = (cbook.get_sample_data('goog.npz', np_load=True)['price_data']
-     .view(np.recarray))
+r = cbook.get_sample_data('goog.npz', np_load=True)['price_data']
 r = r[-250:]  # get the last 250 days
 
 fig, ax = plt.subplots()
-ax.plot(r.date, r.adj_close)
+ax.plot(r["date"], r["adj_close"])
 
 ax.xaxis.set_major_locator(dates.MonthLocator())
 # 16 is a slight approximation since months differ in number of days.
@@ -44,5 +43,5 @@ for tick in ax.xaxis.get_minor_ticks():
     tick.label1.set_horizontalalignment('center')
 
 imid = len(r) // 2
-ax.set_xlabel(str(r.date[imid].item().year))
+ax.set_xlabel(str(r["date"][imid].item().year))
 plt.show()
diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index 4f06790483..2c112e05f5 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -3455,7 +3455,7 @@ class Axes(_AxesBase):
             #     elow, ehigh = np.broadcast_to(...)
             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
             # except that broadcast_to would strip units.
-            low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
+            low, high = dep + np.vstack([-(1 - lolims), 1 - uplims]) * err
 
             barcols.append(lines_func(
                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
@@ -5231,8 +5231,8 @@ default: :rc:`scatter.edgecolors`
         collection = mcoll.PolyCollection(polys, **kwargs)
 
         # now update the datalim and autoscale
-        pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
-                            np.column_stack([ind[where], dep2[where]])])
+        pts = np.vstack([np.hstack([ind[where, None], dep1[where, None]]),
+                         np.hstack([ind[where, None], dep2[where, None]])])
         if ind_dir == "y":
             pts = pts[:, ::-1]
         self.update_datalim(pts, updatex=True, updatey=True)
diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py
index 2a95e5c60c..e3dc940f69 100644
--- a/lib/matplotlib/axes/_base.py
+++ b/lib/matplotlib/axes/_base.py
@@ -2984,7 +2984,7 @@ class _AxesBase(martist.Artist):
                     else:
                         ax.apply_aspect()
                     axs = axs + [ax]
-            top = -np.Inf
+            top = -np.inf
             for ax in axs:
                 if (ax.xaxis.get_ticks_position() in ['top', 'unknown']
                         or ax.xaxis.get_label_position() == 'top'):
diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py
index fe964c250d..412d4a701b 100644
--- a/lib/matplotlib/cbook/__init__.py
+++ b/lib/matplotlib/cbook/__init__.py
@@ -702,7 +702,8 @@ def safe_masked_invalid(x, copy=False):
     if not x.dtype.isnative:
         # If we have already made a copy, do the byteswap in place, else make a
         # copy with the byte order swapped.
-        x = x.byteswap(inplace=copy).newbyteorder('N')  # Swap to native order.
+        # Swap to native order.
+        x = x.byteswap(inplace=copy).view(x.dtype.newbyteorder('N'))
     try:
         xm = np.ma.masked_invalid(x, copy=False)
         xm.shrink_mask()
@@ -1024,7 +1025,7 @@ def _combine_masks(*args):
                 raise ValueError("Masked arrays must be 1-D")
             try:
                 x = np.asanyarray(x)
-            except (np.VisibleDeprecationWarning, ValueError):
+            except (np.exceptions.VisibleDeprecationWarning, ValueError):
                 # NumPy 1.19 raises a warning about ragged arrays, but we want
                 # to accept basically anything here.
                 x = np.asanyarray(x, dtype=object)
@@ -1612,7 +1613,7 @@ def index_of(y):
         pass
     try:
         y = _check_1d(y)
-    except (np.VisibleDeprecationWarning, ValueError):
+    except (np.exceptions.VisibleDeprecationWarning, ValueError):
         # NumPy 1.19 will warn on ragged input, and we can't actually use it.
         pass
     else:
diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py
index c171ff6b99..d7d7033a54 100644
--- a/lib/matplotlib/colors.py
+++ b/lib/matplotlib/colors.py
@@ -615,7 +615,8 @@ class Colormap:
         mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(X)  # Mask nan's.
         xa = np.array(X, copy=True)
         if not xa.dtype.isnative:
-            xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.
+            # Native byteorder is faster.
+            xa = xa.byteswap().view(xa.dtype.newbyteorder())
         if xa.dtype.kind == "f":
             with np.errstate(invalid="ignore"):
                 xa *= self.N
@@ -1875,7 +1876,7 @@ def rgb_to_hsv(arr):
     out = np.zeros_like(arr)
     arr_max = arr.max(-1)
     ipos = arr_max > 0
-    delta = arr.ptp(-1)
+    delta = np.ptp(arr, -1)
     s = np.zeros_like(delta)
     s[ipos] = delta[ipos] / arr_max[ipos]
     ipos = delta > 0
diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py
index e1b5fc3cf7..f7c2393296 100644
--- a/lib/matplotlib/contour.py
+++ b/lib/matplotlib/contour.py
@@ -425,13 +425,13 @@ class ContourLabeler:
             if closed:
                 # This will remove contour if shorter than label
                 if all(i != -1 for i in I):
-                    nlc.append(np.row_stack([xy2, lc[I[1]:I[0]+1], xy1]))
+                    nlc.append(np.vstack([xy2, lc[I[1]:I[0]+1], xy1]))
             else:
                 # These will remove pieces of contour if they have length zero
                 if I[0] != -1:
-                    nlc.append(np.row_stack([lc[:I[0]+1], xy1]))
+                    nlc.append(np.vstack([lc[:I[0]+1], xy1]))
                 if I[1] != -1:
-                    nlc.append(np.row_stack([xy2, lc[I[1]:]]))
+                    nlc.append(np.vstack([xy2, lc[I[1]:]]))
 
             # The current implementation removes contours completely
             # covered by labels.  Uncomment line below to keep
diff --git a/lib/matplotlib/projections/polar.py b/lib/matplotlib/projections/polar.py
index 7ce6292fb8..4f3ab382f3 100644
--- a/lib/matplotlib/projections/polar.py
+++ b/lib/matplotlib/projections/polar.py
@@ -93,7 +93,7 @@ class PolarTransform(mtransforms.Transform):
                         codes.extend(arc.codes[1:])
                 else:  # Interpolate.
                     trs = cbook.simple_linear_interpolation(
-                        np.row_stack([(last_t, last_r), trs]),
+                        np.vstack([(last_t, last_r), trs]),
                         path._interpolation_steps)[1:]
                     xys.extend(self.transform_non_affine(trs))
                     codes.extend([Path.LINETO] * len(trs))
diff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py
index c580043eeb..b7daa1e285 100644
--- a/lib/matplotlib/stackplot.py
+++ b/lib/matplotlib/stackplot.py
@@ -66,7 +66,7 @@ def stackplot(axes, x, *args,
         stacked area plot.
     """
 
-    y = np.row_stack(args)
+    y = np.vstack(args)
 
     labels = iter(labels)
     if colors is not None:
diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py
index eb4c34382b..bf86013da8 100644
--- a/lib/matplotlib/tests/test_axes.py
+++ b/lib/matplotlib/tests/test_axes.py
@@ -1123,7 +1123,7 @@ def test_pcolormesh():
     Qz = np.sin(Y) + np.sin(X)
     Qx = (Qx + 1.1)
     Z = np.hypot(X, Y) / 5
-    Z = (Z - Z.min()) / Z.ptp()
+    Z = (Z - Z.min()) / np.ptp(Z)
 
     # The color array can include masked values:
     Zm = ma.masked_where(np.abs(Qz) < 0.5 * np.max(Qz), Z)
@@ -1148,7 +1148,7 @@ def test_pcolormesh_alpha():
     Qx = X
     Qy = Y + np.sin(X)
     Z = np.hypot(X, Y) / 5
-    Z = (Z - Z.min()) / Z.ptp()
+    Z = (Z - Z.min()) / np.ptp(Z)
     vir = plt.get_cmap("viridis", 16)
     # make another colormap with varying alpha
     colors = vir(np.arange(16))
@@ -1240,7 +1240,7 @@ def test_pcolorargs():
         ax.pcolormesh(x, y, Z[:-1, :-1], shading="gouraud")
     with pytest.raises(TypeError):
         ax.pcolormesh(X, Y, Z[:-1, :-1], shading="gouraud")
-    x[0] = np.NaN
+    x[0] = np.nan
     with pytest.raises(ValueError):
         ax.pcolormesh(x, y, Z[:-1, :-1])
     with np.errstate(invalid='ignore'):
@@ -6527,7 +6527,7 @@ def test_spines_properbbox_after_zoom():
 def test_gettightbbox_ignore_nan():
     fig, ax = plt.subplots()
     remove_ticks_and_titles(fig)
-    ax.text(np.NaN, 1, 'Boo')
+    ax.text(np.nan, 1, 'Boo')
     renderer = fig.canvas.get_renderer()
     np.testing.assert_allclose(ax.get_tightbbox(renderer).width, 496)
 
diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py
index 4fa65918e7..c9398b3747 100644
--- a/lib/matplotlib/tests/test_colors.py
+++ b/lib/matplotlib/tests/test_colors.py
@@ -197,7 +197,7 @@ def test_colormap_endian():
     a = [-0.5, 0, 0.5, 1, 1.5, np.nan]
     for dt in ["f2", "f4", "f8"]:
         anative = np.ma.masked_invalid(np.array(a, dtype=dt))
-        aforeign = anative.byteswap().newbyteorder()
+        aforeign = anative.byteswap().view(anative.dtype.newbyteorder())
         assert_array_equal(cmap(anative), cmap(aforeign))
 
 
@@ -320,7 +320,7 @@ def test_BoundaryNorm():
 
     # Masked arrays
     boundaries = [0, 1.1, 2.2]
-    vals = np.ma.masked_invalid([-1., np.NaN, 0, 1.4, 9])
+    vals = np.ma.masked_invalid([-1., np.nan, 0, 1.4, 9])
 
     # Without interpolation
     ncolors = len(boundaries) - 1
@@ -334,9 +334,9 @@ def test_BoundaryNorm():
     assert_array_equal(bn(vals), expected)
 
     # Non-trivial masked arrays
-    vals = np.ma.masked_invalid([np.Inf, np.NaN])
+    vals = np.ma.masked_invalid([np.inf, np.nan])
     assert np.all(bn(vals).mask)
-    vals = np.ma.masked_invalid([np.Inf])
+    vals = np.ma.masked_invalid([np.nan])
     assert np.all(bn(vals).mask)
 
     # Incompatible extend and clip
@@ -1064,7 +1064,7 @@ def test_light_source_hillshading():
 
         intensity = np.tensordot(normals, illum, axes=(2, 0))
         intensity -= intensity.min()
-        intensity /= intensity.ptp()
+        intensity /= np.ptp(intensity)
         return intensity
 
     y, x = np.mgrid[5:0:-1, :5]
diff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py
index 719b190578..57c1e336c2 100644
--- a/lib/matplotlib/tests/test_image.py
+++ b/lib/matplotlib/tests/test_image.py
@@ -1348,7 +1348,7 @@ def test_rgba_antialias():
     aa[:, int(N/2):] = a[:, int(N/2):]
 
     # set some over/unders and NaNs
-    aa[20:50, 20:50] = np.NaN
+    aa[20:50, 20:50] = np.nan
     aa[70:90, 70:90] = 1e6
     aa[70:90, 20:30] = -1e6
     aa[70:90, 195:215] = 1e6
diff --git a/lib/matplotlib/tests/test_triangulation.py b/lib/matplotlib/tests/test_triangulation.py
index 6001891632..878119c0ec 100644
--- a/lib/matplotlib/tests/test_triangulation.py
+++ b/lib/matplotlib/tests/test_triangulation.py
@@ -901,7 +901,7 @@ def test_trirefine():
     x_verif, y_verif = np.meshgrid(x_verif, x_verif)
     x_verif = x_verif.ravel()
     y_verif = y_verif.ravel()
-    ind1d = np.in1d(np.around(x_verif*(2.5+y_verif), 8),
+    ind1d = np.isin(np.around(x_verif*(2.5+y_verif), 8),
                     np.around(x_refi*(2.5+y_refi), 8))
     assert_array_equal(ind1d, True)
 
diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py
index 2ba5fe7dc7..55872497e2 100644
--- a/lib/mpl_toolkits/mplot3d/art3d.py
+++ b/lib/mpl_toolkits/mplot3d/art3d.py
@@ -746,8 +746,8 @@ class Poly3DCollection(PolyCollection):
     def get_vector(self, segments3d):
         """Optimize points for projection."""
         if len(segments3d):
-            xs, ys, zs = np.row_stack(segments3d).T
-        else:  # row_stack can't stack zero arrays.
+            xs, ys, zs = np.vstack(segments3d).T
+        else:  # vstack can't stack zero arrays.
             xs, ys, zs = [], [], []
         ones = np.ones(len(xs))
         self._vec = np.array([xs, ys, zs, ones])
diff --git a/setup.py b/setup.py
index 330d0d4305..de58449d72 100644
--- a/setup.py
+++ b/setup.py
@@ -315,7 +315,7 @@ setup(  # Finally, pass this all along to setuptools to do the heavy lifting.
     python_requires='>={}'.format('.'.join(str(n) for n in py_min_version)),
     setup_requires=[
         "certifi>=2020.06.20",
-        "numpy>=1.17",
+        "numpy>=2",
         "setuptools_scm>=4,<7",
         "setuptools_scm_git_archive",
     ],
@@ -323,7 +323,7 @@ setup(  # Finally, pass this all along to setuptools to do the heavy lifting.
         "cycler>=0.10",
         "fonttools>=4.22.0",
         "kiwisolver>=1.0.1",
-        "numpy>=1.17",
+        "numpy>=2",
         "packaging>=20.0",
         "pillow>=6.2.0",
         "pyparsing>=2.2.1",
-- 
2.39.5 (Apple Git-154)

